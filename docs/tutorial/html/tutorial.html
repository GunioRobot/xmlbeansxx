<html>
<head>
<title>xmlbeansxx tutorial</title>
<link type="text/css" href="page.css" rel="stylesheet"/>
</head>
<body>
<table class="title" summary="">
<tr>
<td valign="middle">
<h1>Tutorial: First Steps with xmlbeansxx</h1>
</td></tr>
</table>
<h3></h3>
<div style="margin-left: 0 ; border: 2px">
<p>This tutorial introduces <b>xmlbeansxx</b> basics. Through it, you'll get a hands on view of
                the three technologies that make up version 1 of <b>xmlbeansxx</b>: strongly-typed access to
                XML through compiled schema, type-agnostic access to XML through the XML cursor (not
                yet implemented) and xpath query system called XQuery (not yet implemented).
                This tutorial describes what <b>xmlbeansxx</b> is and introduces a few of the tools that come
                with an <b>xmlbeansxx</b> installation.</p>

<p><b>xmlbeansxx</b> is a C++ port of <a href="http://xmlbeans.apache.org">XMLBeans</a> project (developed by
                <a href="http://www.apache.org">The Apache XML Project</a>). This tutorial is
                strongly based on <a href="http://xmlbeans.apache.org/documentation/tutorial_getstarted.html">XMLBeans tutorial</a>.

<p>To get started, you'll need the following:</p>
<ul>
<li>JDK 1.4 for version 1 <b>xmlbeansxx</b> releases. You can download the JDK <a target="_top" href="http://java.sun.com/j2se/1.4.2/download.html">here</a>.</li>
<li>An <b>xmlbeansxx</b> version 1 installation. If you don't have this yet, you'll find
                    installation instructions at <a href="conInstallGuide.html">Installing xmlbeansxx</a>.</li>
<li>An editor for writing C++ code. This could be a text editor or your favorite C++ IDE.</li>
<li>TODO TODO Write exact prerequisites TODO TODO</li>
</ul>

<p>You'll create a few files as part of this tutorial. Start out by creating a new
                tutorials directory just under your XMLBEANS_HOME directory. This will hold the
                files you create in the course of this tutorial. While you're at it, create the
                following subdirectories under the tutorials directory: classes, instances, src,
                lib. If you're working with <b>xmlbeansxx</b> version 1.0.3, your hierarchy should look
                something like this:</p>
<pre class="code">xmlbeansxx-1.0
    ...
    tutorials
        gettingstarted
            classes
            instances
            lib
            src</pre>
</div>
        
<a name="N10034"></a><a name="Get+Acquainted+with+the+Basics"></a>
<h3>Get Acquainted with the Basics</h3>
<div style="margin-left: 0 ; border: 2px">
<p><b>xmlbeansxx</b> version 1 includes multiple related technologies for handling XML. In a
                nutshell, <b>xmlbeansxx</b> offers three complementary technologies:</p>

<ul>
<li>A schema-oriented way to view XML instances through Java types based on the schema.</li>
<li>A schema-agnostic way to traverse the full XML infoset.</li>
<li>A schema object model through which, in Java code, you can examine a compiled
                    XML schema. (Note: this aspect of <b>xmlbeansxx</b> is not covered in this tutorial. For
                    more information, see <a href="../docs/guide/conIntroToTheSchemaTypeSystem.html">Introduction to the
                        Schema Type System.</a></li>
</ul>

<p>There's much more, but that's a start. Each of these three pieces is useful for
                different goals, and you may find yourself writing code that uses all three in the
                same application. The rest of this tutorial will introduce you to these technologies.</p>
</div>
        
<a name="N10051"></a><a name="Getting+Started+with+Handling+XML+Through+Schema"></a>
<h3>Getting Started with Handling XML Through Schema</h3>
<div style="margin-left: 0 ; border: 2px">
<p>One of the things <b>xmlbeansxx</b> does best is provide a way for you to handle XML by using
                a schema to which the XML conforms. With <b>xmlbeansxx</b> you can compile one or more schema
                (XSD) files to generate Java types. By binding XML instance documents to these Java
                types, you provide yourself a way to access the instances in Java in a
                schema-oriented way.</p>

<p>If you don't know anything about schema, here are a few basics for this one:</p>
<ul>
                
<li>This schema is a blueprint, defining the rules for creating a certain "shape" of
                    XML for purchase orders.</li>
                
<li>The purchase order XML defined here would have a <span class="codefrag">&lt;purchase-order&gt;</span>
                    element that has four immediate children: <span class="codefrag">&lt;customer&gt;</span>,
                    <span class="codefrag">&lt;date&gt;</span>, <span class="codefrag">&lt;line-item&gt;</span>, and <span class="codefrag">&lt;shipper&gt;</span> &mdash;

                    in that sequence.</li>
                
<li>Each of the four child elements has its own children in a particular structure,
                    as defined in the schema's respective <span class="codefrag">&lt;complexType&gt;</span> elements.</li>
            
</ul>
<p>Now take a look at an XML document based on this schema. Copy the following XML from
                this page into a new XML file called easypo.xml, then put the file in the
                tutorials\gettingstarted\instances directory you created at the beginning of this tutorial.</p>
<pre class="code">&lt;purchase-order xmlns="http://openuri.org/easypo"&gt;
    &lt;customer&gt;

        &lt;name&gt;Gladys Kravitz&lt;/name&gt;
        &lt;address&gt;Anytown, PA&lt;/address&gt;
    &lt;/customer&gt;
    &lt;date&gt;2003-01-07T14:16:00-05:00&lt;/date&gt;

    &lt;line-item&gt;
        &lt;description&gt;Burnham's Celestial Handbook, Vol 1&lt;/description&gt;
        &lt;per-unit-ounces&gt;5&lt;/per-unit-ounces&gt;
        &lt;price&gt;21.79&lt;/price&gt;

        &lt;quantity&gt;2&lt;/quantity&gt;
    &lt;/line-item&gt;
    &lt;line-item&gt;
        &lt;description&gt;Burnham's Celestial Handbook, Vol 2&lt;/description&gt;
        &lt;per-unit-ounces&gt;5&lt;/per-unit-ounces&gt;

        &lt;price&gt;19.89&lt;/price&gt;
        &lt;quantity&gt;2&lt;/quantity&gt;
    &lt;/line-item&gt;
    &lt;shipper&gt;
        &lt;name&gt;ZipShip&lt;/name&gt;

        &lt;per-ounce-rate&gt;0.74&lt;/per-ounce-rate&gt;
    &lt;/shipper&gt;
&lt;/purchase-order&gt;</pre>
<p>This XML represents a purchase order in through which Gladys, an amateur astronomer,
                is buying two books to use as references in her stargazing (along with an extra copy
                of each for her niece). Because this XML is an instance of the schema, you'll
                recognize the <span class="codefrag">&lt;purchase-order&gt;</span> element and its children,
                <span class="codefrag">&lt;customer&gt;</span>, <span class="codefrag">&lt;date&gt;</span>, <span class="codefrag">&lt;line-item&gt;</span>, and <span class="codefrag">&lt;shipper&gt;</span>.</p>

<p>Now to try these examples out with <b>xmlbeansxx</b>. Among the tools included with <b>xmlbeansxx</b>
                is scompxx, a script that executes the schema compiler (part of the <b>xmlbeansxx</b> API) to
                compile a schema or directory of schemas. Use scompxx to compile the easypo schema. On
                Windows, use the following command (this script is also available on UNIX):</p>
<pre class="code">scompxx -out tutorials\gettingstarted\lib\easypo.jar schemas\easypo\easypo.xsd</pre>
<p>You'll end up with easypo.jar in the lib directory of your tutorial hierarchy.</p>


<a name="N100B8"></a><a name="Results+of+Compiling+the+Schema"></a>
<h4>Results of Compiling the Schema</h4>
<div style="margin-left: 0 ; border: 2px">
<p>[This section describes the interfaces generated by the schema compiler. If
                    you're familiar with this want to skip to writing Java code, go to <a href="#writing_code_that_uses_types">Writing Code
                    that Uses Generated Types</a>.]</p>
<p>The schema compiler's output is designed not only to provide a JavaBeans-oriented
                    view of your schema, but to anticipate the shortcuts you're likely to want. If
                    you compare the contents of easypo.xsd with the Java types generated by
                    compiling it, you'll see obvious parallels. For each of the elements and schema
                    types defined in the schema, the schema compiler has generated Java types. The
                    package namespace corresponds to the schema's namespace URI.</p>
<p>For example, take another look at the &lt;purchase-order&gt; element
                    defined in the schema:</p>

<pre class="code">&lt;xs:element name="purchase-order"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="customer" type="po:customer"/&gt;
            &lt;xs:element name="date" type="xs:dateTime"/&gt;
            &lt;xs:element name="line-item" type="po:line-item" minOccurs="0" maxOccurs="unbounded"/&gt;

            &lt;xs:element name="shipper" type="po:shipper" minOccurs="0" maxOccurs="1"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</pre>
<p>This snippet defines the <span class="codefrag">&lt;purchase-order&gt;</span> element as having a
                    "local" complex type (also known as an "anonymous" complex type). This type
                    includes a sequence of child elements (in the schema world,
                    <span class="codefrag">&lt;sequence&gt;</span> is a "compositor" and each <span class="codefrag">&lt;element&gt;</span> is a
                    "particle"). The <span class="codefrag">&lt;date&gt;</span> element is specified as an xs:dateTime, a
                    built-in type defined by the W3C's schema data type specification; the other
                    three elements are complex types defined elsewhere in this schema.</p>

<a name="N100DF"></a><a name="Options+for+Accessing+Elements+of+Built-In+Schema+Types"></a>
<h5>Options for Accessing Elements of Built-In Schema Types</h5>
<div style="margin-left: 0 ; border: 2px">
<p>To represent the <span class="codefrag">&lt;purchase-order&gt;</span> element, the
                        schema compiler has generated a <span class="codefrag">PurchaseOrder</span> class that
                        extends <a href="http://DOCS/reference/xmlbeans/XmlObject.html">
                            <span class="codefrag">xmlbeansxx::XmlObject</span>

                        </a>. As well as this class scompxx generated another one: <span class="codefrag">PurchaseOrderDocument</span>.
                        <b>xmlbeansxx</b> does this
                        for <span class="codefrag">"global"</span> element and attributes &mdash; those defined at the
                        top level of the schema. This is to provide you with a way to get and set
                        the global item as a whole piece, which would be difficult to do if it
                        weren't contained by anything. In other words, you need a type on which to
                        methods such as <span class="codefrag">getPurchaseOrder</span> and
                        <span class="codefrag">setPurchaseOrder</span> and this <span class="codefrag">"Document"</span>
                        class fills that role.</p>
                        
                        <p> For each of <span class="codefrag">&lt;purchase-order&gt;</span>'s four child
                        elements, the <span class="codefrag">PurchaseOrder</span> class exposes accessors
                        according to JavaBeans conventions. For example, for the
                        <span class="codefrag">&lt;date&gt;</span> element you have the following:</p>
<pre class="code">public:
        java.util.Calendar getDate()
        void setDate ( java.util.Calendar )</pre>

<p>This is one of two ways that the schema compiler provides for access to the
                        <span class="codefrag">&lt;date&gt;</span> element &mdash; a more convenient, Java-native
                        way, one might say. These accessors are a kind of convenience pair (you're
                        likely to want a <span class="codefrag">Calendar</span> instance when working with a date).
                        However, because the <span class="codefrag">&lt;date&gt;</span> element's type,
                        <span class="codefrag">xs:dateTime</span>, is a built-in schema type, the schema compiler
                        provides accessors that get and set its value with another Java type that
                        <b>xmlbeansxx</b> defines:</p>

<pre class="code">public:
        xmlbeansxx::XmlDateTime xgetDate()
        void xsetDate( xmlbeansxx::XmlDateTime )</pre>
<p>
                        
<a href="http://xmlbeans.apache.org/docs/reference/org/apache/xmlbeans/XmlDateTime.html">
                            <span class="codefrag">XmlDateTime</span>
                        </a> can be seen as a Rosetta Stone. With it, you can get and set the
                        element's value using <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Calendar.html">
                            <span class="codefrag">java.util.Calendar</span>
                        </a>, <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Date.html">

                            <span class="codefrag">java.util.Date</span>
                        </a>, and <a href="http://xmlbeans.apache.org/docs/reference/org/apache/xmlbeans/GDate.html">
                            <span class="codefrag">org.apache.xmlbeans.GDate</span>
                        </a>. (For a full list of how built-in schema types are mapped to Java
                        types by the compiler, see <a href="http://xmlbeans.apache.org/docs/guide/con<b>xmlbeansxx</b>SupportBuiltInSchemaTypes.html">xmlbeansxx
                            Support for Built-In Schema Types</a>.) </p>
</div>

<a name="N10150"></a><a name="Access+for+Elements+of+User-Defined+Schema+Types"></a>
<h5>Access for Elements of User-Defined Schema Types</h5>

<div style="margin-left: 0 ; border: 2px">
<p>For the three elements whose types are defined <em>within</em> the schema,
                        the compiler generates separate C++ classes and uses these in accessors &mdash; as
                        below for the <span class="codefrag">&lt;customer&gt;</span> element's
                        <span class="codefrag">customer</span> type.</p>
<pre class="code">public:
        org::openuri::easypo::Customer getCustomer()
        void setCustomer( org::openuri::easypo::Customer )</pre>
<p>In other words you can call <span class="codefrag">getCustomer</span> to retrieve its
                        <span class="codefrag">Customer</span> instance, then update the instance's contents &mdash; which
                        is how you update the content of the <span class="codefrag">&lt;customer&gt;</span>

                        element it represents. </p>
<p>Along the same lines, you get a convenience method for complex types like
                        <span class="codefrag">customer</span>, like so:</p>
<pre class="code">public:
        org::openuri::easypo::Customer addNewCustomer()</pre>
<p>Through an <span class="codefrag">add*</span> method such as this one, you can add a new
                        <span class="codefrag">&lt;customer&gt;</span> element to the
                        <span class="codefrag">&lt;purchase-order&gt;</span> element. The method returns a
                        <span class="codefrag">Customer</span> instance so that you can update the new element's
                        contents. </p>

<p>Other convenience methods are provided for elements and attributes that
                        schema defines as optional. The <span class="codefrag">&lt;shipper&gt;</span> element
                        is optional because the schema specifies its <span class="codefrag">minOccurs</span>
                        attribute value as <span class="codefrag">0</span> (the default value for this attribute is
                        <span class="codefrag">1</span>). As a result, the element need not exist in the XML in order
                        for the instance to be valid. To find out if it's there and to remove it if
                        it is, you get these methods:</p>
<pre class="code">public:
        boolean isSetShipper ( ) 
        void unsetShipper ( )</pre>
</div>

<a name="N101A2"></a><a name="Arrays+for+Accessing+Elements+That+May+Occur+More+Than+Once"></a>
<h5>Arrays for Accessing Elements That May Occur More Than Once</h5>
<div style="margin-left: 0 ; border: 2px">
<p>Another optional element defined by the schema is
                        <span class="codefrag">&lt;line-item&gt;</span>. However, there's an important
                        difference for <span class="codefrag">&lt;line-item&gt;</span> &mdash; its
                        <span class="codefrag">maxOccurs</span> attribute's value is "unbounded,"
                        meaning it may occur multiple times as a child of
                        <span class="codefrag">&lt;purchase-order&gt;</span> (like <span class="codefrag">minOccurs</span>,
                        the default of <span class="codefrag">maxOccurs</span> is <span class="codefrag">1</span>). A common Java way
                        to handle multiple instances of the same type is through an array of that
                        type &mdash; and that's exactly what the schema compiler gives you:</p>

<pre class="code">public:
        // Get or set the whole array.
        org::openuri::easypo::LineItem[] getLineItemArray ( )
        void setLineItemArray ( org::openuri::easypo::LineItem[] )

        // Get or set a single item.
        org::openuri::easypo::LineItem getLineItemArray ( int )
        void setLineItemArray( int, org::openuri::easypo::LineItem )

        // Add or remove an item.
        org::openuri::easypo::LineItem insertNewLineItem( int )
        void removeLineItem( int )

        // Get the array's size (without having to get the array, then call .length).
        int sizeOfLineItemArray()</pre>
<p>Finally, you'll notice that the schema compiler has generated a <span class="codefrag">field</span>:</p>
<pre class="code">public static final org.apache.xmlbeans.SchemaType type</pre>
<p>You can use this field for access to a <a href="http://xmlbeans.apache.org/docs/reference/org/apache/xmlbeans/SchemaType.html">
                            <span class="codefrag">SchemaType</span>
                        </a> instance that represents the underlying schema type itself. This
                        will be covered in the last part of this tutorial.</p>

<div class="frame note">
<div class="label">Note</div>
<div class="content">For more information about the types generated from schema, see
        <a href="../docs/guide/conJavaTypesGeneratedFromUserDerived.html">Java Types Generated from User-Derived Schema Types</a>.
        To learn more about generated methods, see
        <a href="../docs/guide/conMethodsForGeneratedJavaTypes.html">Methods for Types Generated from Schema</a>.
        Also, <b>xmlbeansxx</b> provides its own Java types for built-in schema data types such as
        <span class="codefrag">xs:dateTime</span>, <span class="codefrag">xs:decimal</span>, and so on.
        To read more about these, see
        <a href="../docs/guide/con<b>xmlbeansxx</b>SupportBuiltInSchemaTypes.html">xmlbeansxx Support for Built-In Schema Types</a>.</div>
</div>
</div>

</div>

<a name="writing_code_that_uses_types"></a><a name="N101F4"></a><a name="Writing+Code+that+Uses+Generated+Types"></a>
<h4>Writing Code that Uses Generated Types</h4>
<div style="margin-left: 0 ; border: 2px">
<p>You're going to write a bit of code to add a new line item to the purchase order.
                    It turns out that Gladys wants to add another book to her order. Your code will
                    accept the existing order along with raw data for the new item, then add the
                    item and return the updated XML.</p>
<p>Start out by creating a POUpdater.cpp file in the
                    <span class="codefrag">tutorials\gettingstarted\src</span> directory. Add the following code to
                    that file:</p>
<pre class="code">#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;easypo.h&gt;

using namespace std;
using namespace xmlbeansxx;
using namespace org::openuri::easypo;

string addLineItem(istream purchaseOrder, string itemDescription,
                                  string perUnitOuncesString, 
                                  string itemPriceString, string itemQuantityString) {
        // Bind the incoming XML to an xmlbeansxx type.
        PurchaseOrderDocumentPtr poDoc;
        poDoc = PurchaseOrderDocument::parse(purchaseOrder);

        return poDoc->toString();
}</pre>
<p>So far, the <span class="codefrag">addLineItem</span> function binds the incoming XML to an <b>xmlbeansxx</b>
                    type generated by compiling the schema. This snippet creates a function that
                    receives a <span class="codefrag">File</span> instance representing the purchase order XML, as
                    well as strings containing the raw data that will comprise the new item added.
                    You bind the XML <em>document</em> &mdash; the root element and its children &mdash; to the
                    <span class="codefrag">PurchaseOrderDocument</span> class. This class, like all types
                    extending <a href="http://xmlbeans.apache.org/docs/reference/org/apache/xmlbeans/XmlObject.html"><span class="codefrag">XmlObject</span></a>
                    (including all types generated from schema), provides a
                    <span class="codefrag">Factory</span> methods with which to create new instances. The
                    <span class="codefrag">Factory</span> methods are various versions of the <span class="codefrag">parse</span>
                    method, each receiving XML source as a different C++ type.</p>

<p>The method's next bit of code, shown below, converts the incoming raw data into
                    types that can be used when creating the new <span class="codefrag">&lt;line-item&gt;</span> element.
                    It then adds the new element and sets that element's children's values. Remember
                    that, in <b>xmlbeansxx</b>, you get at the type representing a global element by going
                    through the <span class="codefrag">"Document"</span> type that contains it &mdash; here, with the
                    <span class="codefrag">getPurchaseOrder</span> method. </p>
<pre class="code">BigDecimal perUnitOunces = new BigDecimal(perUnitOuncesString);
BigDecimal itemPrice = new BigDecimal(itemPriceString);
BigInteger itemQuantity = new BigInteger(itemQuantityString);

LineItem newItem = poDoc.getPurchaseOrder().addNewLineItem();
newItem.setDescription(itemDescription);
newItem.setPerUnitOunces(perUnitOunces);
newItem.setPrice(itemPrice);
newItem.setQuantity(itemQuantity);</pre>
<p>That's pretty much all there is to it. The JavaBeans-style access provided by
                    compiling your schema greatly simplifies your access to XML instances based on
                    the schema. </p>

<p>Here's a full version of the <span class="codefrag">POUpdater</span> class, with the
                    <span class="codefrag">addLineItem</span> method accessible via a <span class="codefrag">main</span> method.</p>
<pre class="code">public class POUpdater
{
    public static void main(String[] args)
    {
        File poXmlFile = new File(args[0]);
        String updatedPoXml = addLineItem(poXmlFile, args[1], args[2],
            args[3], args[4]);
        System.out.println(updatedPoXml);
    }

    private static String addLineItem(File purchaseOrder, String itemDescription,
                                      String perUnitOuncesString, 
                                      String itemPriceString, String itemQuantityString)
    {
        PurchaseOrderDocument poDoc = null;
        try
        {
            // Bind the incoming XML to an <b>xmlbeansxx</b> type.
            poDoc = PurchaseOrderDocument.Factory.parse(purchaseOrder);
        } catch (XmlException e)
        {
            e.printStackTrace();
        } catch (IOException e)
        {
            e.printStackTrace();
        }

        // Convert incoming data to types that can be used in accessors.
        BigDecimal perUnitOunces = new BigDecimal(perUnitOuncesString);
        BigDecimal itemPrice = new BigDecimal(itemPriceString);
        BigInteger itemQuantity = new BigInteger(itemQuantityString);

        // Add the new &lt;line-item&gt; element.
        LineItem newItem = poDoc.getPurchaseOrder().addNewLineItem();
        newItem.setDescription(itemDescription);
        newItem.setPerUnitOunces(perUnitOunces);
        newItem.setPrice(itemPrice);
        newItem.setQuantity(itemQuantity);

        return poDoc.toString();
    }
}</pre>
<p>Now, compile the new class with a command such as the following (the line is
                    broken for readability):</p>

<pre class="code">javac -classpath $XMLBEANS_HOME/lib/xbean.jar:tutorials/gettingstarted/lib/easypo.jar 
    POUpdater instances/easypo/easypo.xml "a new item" 5.0 20.00 6</pre>
<p>After you compile, you can try out the class with the following command (again,
                    broken for readability):</p>
<pre class="code">java -cp tutorials/gettingstarted/classes:$XMLBEANS_HOME/lib/xbean.jar:tutorials/gettingstarted/lib/easypo.jar 
    POUpdater tutorials/gettingstarted/instances/easypo.xml "a new item" 5.0 20.00 6</pre>
<p>The output should look like the instance output above, but with the following
                    added as the last <span class="codefrag">&lt;line-item&gt;</span> element, immediately
                    before the <span class="codefrag">&lt;shipper&gt;</span> element. </p>
<pre class="code">&lt;line-item&gt;
    &lt;description&gt;Backyard Astronomer's Guide, The&lt;/description&gt;

    &lt;per-unit-ounces&gt;5.0&lt;/per-unit-ounces&gt;
    &lt;price&gt;49.95&lt;/price&gt;
    &lt;quantity&gt;2&lt;/quantity&gt;
&lt;/line-item&gt;</pre>

<p>Obviously, you need a schema to use this aspect of <b>xmlbeansxx</b>. But you may find
                    yourself creating a schema where you only have instances so that you can compile
                    it to generate those Java types &mdash; just to make your life a little easier.</p>
</div>
</div>
      

        
<a name="N1026F"></a><a name="Getting+Started+with+the+XML+Cursor"></a>
<h3>Getting Started with the XML Cursor</h3>
<div style="margin-left: 0 ; border: 2px">
This part will be added after XML Cursor functionality is implemented.
</div>

      
<a name="N103C4"></a><a name="Where+to+Go+from+Here"></a>
<h3>Where to Go from Here</h3>
<div style="margin-left: 0 ; border: 2px">
<ul>
                
<li>Be sure to check out the <a href="http://xmlbeans.apache.org/documentation/index.html"><b>xmlbeansxx</b> documentation</a>.</li>
                
<li>The <a href="http://xmlbeans.apache.org/resources/index.html"><b>xmlbeansxx</b>
                    Resources</a> page provides links to lots of articles.</li>

            
</ul>
</div>
    
<!--================= start Footer ==================-->
<table summary="footer" cellspacing="0" cellpadding="0" width="100%" border="0">
<tr>

<td colspan="2" height="1" bgcolor="#4C6C8F"><img height="1" width="1" alt="" src="images/spacer.gif" class="spacer"><a href="http://xmlbeans.apache.org/skin/images/label.gif"></a><a href="http://xmlbeans.apache.org/skin/images/page.gif"></a><a href="http://xmlbeans.apache.org/skin/images/chapter.gif"></a><a href="http://xmlbeans.apache.org/skin/images/chapter_open.gif"></a><a href="http://xmlbeans.apache.org/skin/images/current.gif"></a><a href="/favicon.ico"></a></td>
</tr>
<tr>
<td colspan="2" bgcolor="#CFDCED" class="copyright" align="center"><font size="2" face="Arial, Helvetica, Sans-Serif">Copyright &copy;
          2004&nbsp;The Apache Software Foundation. All rights reserved.<script type="text/javascript" language="JavaScript"><!--
              document.write(" - "+"Last Published: " + document.lastModified);
            //  --></script></font></td>
</tr>
<tr>
<td colspan="2" align="left" bgcolor="#CFDCED" class="logos"></td>
</tr>
</table>
<!--================= end Footer ==================-->
</body>

</html>
