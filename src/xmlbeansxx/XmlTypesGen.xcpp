/*
    Copyright 2004-2005 TouK s.c.
    
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License. */



%%preamble
#include <log4cxx/logger.h>

#include "TextUtils.h"
#include "TypeSystem.h"
#include "XmlParser.h"
#include "xml-fragment.h"
#include "defs.h"
#include "Query.h"
#include "XmlArray.h"

#include "BeansException.h"
#include "Tracer.h"


//Enable tracing methods
//#define TRACER2 TRACER

//Disable tracing methods
#define TRACER2(log,msg)


namespace xmlbeansxx {
std::string istreamToString(std::istream &in) {
    std::string s,s2;
    while (true) {
        in>>s2;
        if (in.eof())
            break;
        s+=s2;
    }
    return s;
}

class NoExchangeEntitiesXmlObject: public XmlObject {
    Contents _contents;
    public:
    virtual Contents *getContents() const {
        return const_cast<Contents *>(&_contents);
    }
    virtual std::string exchangeEntities(const std::string& str) const { return str; }
};


DECLARE_PTR_CODE(std::string,StringPtr,constStringPtr)

Map_String_Int::Map_String_Int() {}
/*
Map_String_Int::Map_String_Int(const Map_String_Int &b): std::map<std::string,int>(b) {}

}*/

Map_String_Int::Map_String_Int(const Map_String_Int &b): __gnu_cxx::hash_map<StoreString,int,StoreStringHashFn>(b) {}

}

%%class xmlbeansxx::XmlObject
log4cxx::LoggerPtr XmlObject::log = log4cxx::Logger::getLogger(std::string("xmlbeansxx.XmlObject"));

XmlObject::~XmlObject() {
}

int XmlObject::documentElementNamespaceID() const { return -1; }

std::string XmlObject::digest() {
    return getContents()->digest(this); 
}

bool XmlObject::setAnyElement(std::string elementName,std::string anyContent) {
    boost::shared_ptr<NoExchangeEntitiesXmlObject> obj(new NoExchangeEntitiesXmlObject);
    obj->setSimpleContent(anyContent);
    getContents()->setElem(elementName,obj);
    return true;
}

void XmlObject::serialize(std::ostream &o,const XmlOptionsPtr &options) const {
    TRACER(log,"serialize")

    if (options->getPrintXmlDeclaration())
        o<<"<?xml version='1.0' encoding='UTF-8'?>\n";

    o<<"<d:xml-fragment xmlns:d='http://xmlbeans.apache.org/definitions' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xmlns:xs='http://www.w3.org/2001/XMLSchema'><d:element";
    getContents()->serialize2(-1,true,"d:element",o,this);
    o<<"</d:xml-fragment>\n";

    /* 
    definitions::XmlFragmentDocument doc;
    XmlObjectPtr obj(newSameType());
    obj->getContents()->simpleCopyFrom(this->contents);
    obj->setSimpleContent(getSimpleContent());
    //doc.setXmlFragment(XmlObjectPtr(boost::const_pointer_cast<XmlObject>(shared_from_this())));
    doc.cgetXmlFragment()->setElement(obj);
    doc.serialize(out,options);
    */
}

std::string XmlObject::toString(const XmlOptionsPtr &options) const {
    std::ostringstream ss;
    serialize(ss,options);
    return ss.str();
}

#ifdef BOOST_HAS_THREADS
boost::recursive_mutex &XmlObject::mutex() const {
    return getContents()->mutex;
}
#endif

XmlObjectPtr XmlObject::clone() const {
    XmlObjectPtr n=getSchemaType()->createFn();
    n->getContents()->copyFrom(this->getContents());
    n->setSimpleContent(getSimpleContent());
    return n;
}

std::string XmlObject::getSimpleContent() const {
    //logger.debug("XmlObject::getSimpleContent");
    return getContents()->getSimpleContent();
}

void XmlObject::setSimpleContent(const std::string &value) {
    //logger.debug("XmlObject::setSimpleContent");
    const SchemaType *st=getSchemaType();
    
    SchemaType::CONTENT_TYPE ct=st->getContentType();
    if (ct==SchemaType::SIMPLE_CONTENT || ct==SchemaType::MIXED_CONTENT || ct==SchemaType::NOT_COMPLEX_TYPE) {
        if (getSchemaType()->whitespaceRule==SchemaType::WS_COLLAPSE) {
            getContents()->setSimpleContent(TextUtils::collapse(value));
        } else {
            getContents()->setSimpleContent(value);
        }
    }
}

std::string XmlObject::getCanonicalContent() const {
    return getSimpleContent();
}

XmlObjectPtr XmlObject::query(std::string elementName,const QueryNodePtr &queryExpr) const {
    TRACER2(log,"query")
    shared_array<XmlObjectPtr> elems=getContents()->getElemArray(elementName);
    
    FOREACH(it,elems) {
        if (*it!=NULL) {
            if (queryExpr->getBooleanValue(*it)) {
                return *it;
            }
        }
    }
    return XmlObjectPtr();
}

XmlObjectPtr XmlObject::cquery(std::string elementName,const QueryNodePtr &queryExpr,ObjectCreatorFn createFn) {
    TRACER2(log,"cquery")
    
    XmlObjectPtr r=query(elementName,queryExpr);
    if (r==NULL) {
        r=createFn();
        getContents()->appendElem(elementName,r);
    }
    return r;
}

void XmlObject::free() {
    getContents()->free();
}

std::string XmlObject::exchangeEntities(const std::string& str) const {
    return TextUtils::exchangeEntities(str);
}

/*
template<class T>
boost::shared_ptr<T> XmlObject::defaultValue(boost::shared_ptr<T> value,std::string defaultText) const {
    if (value==NULL) { 
        value=boost::shared_ptr<T>(new T());
        value->setSimpleContent(defaultText);
    }
    return value;
}

template<class T>
std::vector<boost::shared_ptr<T> > &XmlObject::defaultArrayValue(std::vector<boost::shared_ptr<T> > &array_value,std::string defaultText) const {
    typename std::vector<boost::shared_ptr<T> >::iterator it;
    for(it=array_value.begin();it!=array_value.end();it++) {
        if (*it==NULL) {
            *it=boost::shared_ptr<T>(new T());
            it->setSimpleContent(defaultText);
        }
    }
    return array_value;
}*/

%%class xmlbeansxx::XmlAnySimpleType
std::string XmlAnySimpleType::getStringValue() const {
    return getContents()->getSimpleContent();
}

void XmlAnySimpleType::setStringValue(const std::string &v) {
    getContents()->setSimpleContent(v);
}


%%class xmlbeansxx::XmlBoolean
log4cxx::LoggerPtr XmlBoolean::log = log4cxx::Logger::getLogger(std::string("xmlbeansxx.XmlBoolean"));

bool XmlBoolean::getBooleanValue() const {
    TRACER2(log,"getBooleanValue")
    LOG4CXX_DEBUG(log,"value:"+getContents()->getSimpleContent());
    bool boolVal;
    if (getContents()->getSimpleContent()=="0") {
        boolVal=false;
    } else if (getContents()->getSimpleContent()=="1") {
        boolVal=true;
    } else if (getContents()->getSimpleContent()=="false") {
        LOG4CXX_DEBUG(log,"is false"); boolVal=false;
    } else if (getContents()->getSimpleContent()=="true") {
        boolVal=true;
    } else throw XmlIllegalValueException("xs:boolean",getContents()->getSimpleContent());
    return boolVal;
}

void XmlBoolean::setBooleanValue(bool v) {
    if (v==true) getContents()->setSimpleContent("true");
    else getContents()->setSimpleContent("false");
}

std::string XmlBoolean::getCanonicalContent() const {
    bool b=getBooleanValue();
    if (b) return "true";
    else return "false";
}

bool XmlBoolean::operator==(bool b) const {
    return getBooleanValue()==b;
}

bool XmlBoolean::operator !() const {
   return !getBooleanValue();
}

bool XmlBoolean::operator ||(bool b) const {
    return getBooleanValue() || b;
}

bool XmlBoolean::operator &&(bool b) const {
    return getBooleanValue() && b;
}

XmlBoolean::operator bool() const {
    return getBooleanValue();
}

%%class xmlbeansxx::XmlBoolean::Factory
XmlBooleanPtr xmlbeansxx::XmlBoolean::Factory::newInstance(bool value) { 
    XmlBooleanPtr v(newInstance());
    v->setBooleanValue(value); 
    return v;
}

XmlBooleanPtr xmlbeansxx::XmlBoolean::Factory::newInstance(const char *value) {
    XmlBooleanPtr v(newInstance());
    v->setSimpleContent(value);
    return v;
}


%%class xmlbeansxx::XmlString
log4cxx::LoggerPtr XmlString::log = log4cxx::Logger::getLogger(std::string("xmlbeansxx.XmlString"));

XmlString::operator std::string() const {
    return getSimpleContent();
}

bool XmlString::operator==(const std::string &b) const {
    return getSimpleContent() == b;
}
bool XmlString::operator!=(const std::string &b) const {
    return getSimpleContent() != b;
}

std::string XmlString::operator+(const std::string &b) const {
    return getSimpleContent() + b;
}

std::string XmlString::substring(int beginIndex) const {
    return substring(beginIndex,length());
}

std::string XmlString::substring(int beginIndex,int endIndex) const {
    TRACER2(log,"substring")
    std::string s(getSimpleContent());
    if (beginIndex<0) {
        beginIndex+=s.size();
    }
    if (endIndex<0) {
        endIndex+=s.size();
    }
    if (!( beginIndex>=0 && beginIndex<=int(s.size()) && 
           endIndex>=0 && endIndex<=int(s.size()) &&
           beginIndex<=endIndex ))
        throw IllegalArgumentsException(std::string("in substring '")+s
                +"' beginIndex:"+TextUtils::intToString(beginIndex)
                +" endIndex:"+TextUtils::intToString(endIndex));
    
    return s.substr(beginIndex,endIndex-beginIndex);
}

bool XmlString::endsWith(const std::string &s) const {
    std::string s2=getSimpleContent();
    return s2.substr(s2.size()-s.size())==s;
}

int XmlString::length() const {
    return getSimpleContent().size();
}

%%class xmlbeansxx::XmlInteger
log4cxx::LoggerPtr XmlInteger::log = log4cxx::Logger::getLogger(std::string("xmlbeansxx.XmlIteger"));

void XmlInteger::setSimpleContent(const std::string &value) {
    getContents()->setSimpleContent(value);
    setMpzValue(getMpzValue());
}

XmlInteger::operator int() const {
    return getIntValue();
}
XmlInteger::operator mpz_class() const {
    return getMpzValue();
}
    
mpz_class XmlInteger::operator+(const mpz_class &b) const {
    return getMpzValue()+b;
}
mpz_class XmlInteger::operator-(const mpz_class &b) const {
    return getMpzValue()-b;
}
mpz_class XmlInteger::operator*(const mpz_class &b) const {
    return getMpzValue()*b;
}
mpz_class XmlInteger::operator/(const mpz_class &b) const {
    return getMpzValue()/b;
}

void XmlInteger::operator+=(const mpz_class &b) {
    setMpzValue(getMpzValue()+b);
}
void XmlInteger::operator-=(const mpz_class &b) {
    setMpzValue(getMpzValue()-b);
}
void XmlInteger::operator*=(const mpz_class &b) {
    setMpzValue(getMpzValue()*b);
}
void XmlInteger::operator/=(const mpz_class &b) {
    setMpzValue(getMpzValue()/b);
}

bool XmlInteger::operator==(const mpz_class &b) const {
    return getMpzValue()==b;
}
bool XmlInteger::operator!=(const mpz_class &b) const {
    return getMpzValue()!=b;
}
bool XmlInteger::operator<=(const mpz_class &b) const {
    return getMpzValue()<=b;
}
    

%%class xmlbeansxx::XmlInteger::Factory
XmlIntegerPtr XmlInteger::Factory::newInstance(const char *value) {
    XmlIntegerPtr v(newInstance());
    v->setSimpleContent(value);
    return v;
}

XmlIntegerPtr XmlInteger::Factory::newInstance(int value) { 
    XmlIntegerPtr v(newInstance());
    v->setIntValue(value); 
    return v;
}

XmlIntegerPtr XmlInteger::Factory::newInstance(const mpz_class &value) { 
    XmlIntegerPtr v(newInstance());
    v->setMpzValue(value); 
    return v;
}
    
%%class xmlbeansxx::XmlDecimal
log4cxx::LoggerPtr XmlDecimal::log = log4cxx::Logger::getLogger(std::string("xmlbeansxx.XmlDecimal"));

mpf_class XmlDecimal::getMpfValue() const {
    TRACER2(log,"getMpfValue")
    std::string v=TextUtils::collapse(getContents()->getSimpleContent());
    if (!TextUtils::checkDecimal(v)) 
        throw XmlIllegalValueException("xs:decimal",v);
    return mpf_class(v);
}

void XmlDecimal::setMpfValue(const mpf_class &v) {
    std::ostringstream ss;
    ss << std::fixed;
    int fd=getSchemaType()->fractionDigits;
    if (fd!=-1) { ss.precision(fd); }
    ss << v;
    getContents()->setSimpleContent(ss.str());
}

mpz_class XmlDecimal::getMpzValue() const {
    TRACER2(log,"getMpzValue")
    std::string v=TextUtils::collapse(getContents()->getSimpleContent());
    if (!TextUtils::checkInteger(v)) 
        throw XmlIllegalValueException("xs:integer",v);
    return mpz_class(v);
}

void XmlDecimal::setMpzValue(const mpz_class &v) {
    std::ostringstream ss;
    ss << v;
    getContents()->setSimpleContent(ss.str());
}

int XmlDecimal::getIntValue() const {
    mpz_class v=getMpzValue();
    if (v.fits_sint_p()) {
        return v.get_si();
    } else {
        throw IllegalArgumentsException(std::string("Cannot convert decimal='")+getSimpleContent()+std::string("' to int."));
        return 0;
    }
}

void XmlDecimal::setIntValue(int v) {
    setMpzValue(v);
}

mpz_class XmlDecimal::getLongValue() const {
    return getMpzValue();
}

void XmlDecimal::setLongValue(mpz_class v) {
    setMpzValue(v);
}
    
short XmlDecimal::getShortValue() const {
    int v=getIntValue();
    if (!(v>=-32768 && v<=32767)) {
        throw IllegalArgumentsException(std::string("Cannot convert decimal='")+getSimpleContent()+std::string("' to short."));
        return 0;
    }
    return v;
}

void XmlDecimal::setShortValue(short v) {
    setIntValue(v);
}


unsigned char XmlDecimal::getByteValue() const {
    int v=getIntValue();
    if (!(v>=0 && v<=255)) {
        throw IllegalArgumentsException(std::string("Cannot convert decimal='")+getSimpleContent()+std::string("' to byte."));
        return 0;
    }
    return v;
}

void XmlDecimal::setByteValue(unsigned char v) {
    setIntValue(v);
}


void XmlDecimal::setSimpleContent(const std::string &value) {
    getContents()->setSimpleContent(value);
    setMpfValue(getMpfValue());
}

XmlDecimal::operator mpf_class() const {
    return getMpfValue();
}

mpf_class XmlDecimal::operator+(const mpf_class &b) const {
    return getMpfValue()+b;
}

mpf_class XmlDecimal::operator-(const mpf_class &b) const {
    return getMpfValue()-b;
}

mpf_class XmlDecimal::operator*(const mpf_class &b) const {
    return getMpfValue()*b;
}

mpf_class XmlDecimal::operator/(const mpf_class &b) const {
    return getMpfValue()/b;
}

void XmlDecimal::operator+=(const mpf_class &b) {
    setMpfValue(getMpfValue()+b);
}

void XmlDecimal::operator-=(const mpf_class &b) {
    setMpfValue(getMpfValue()-b);
}

void XmlDecimal::operator*=(const mpf_class &b) {
    setMpfValue(getMpfValue()*b);
}

void XmlDecimal::operator/=(const mpf_class &b) {
    setMpfValue(getMpfValue()/b);
}


bool XmlDecimal::operator==(const mpf_class &b) const {
    return getMpfValue()==b;
}

bool XmlDecimal::operator!=(const mpf_class &b) const {
    return getMpfValue()!=b;
}

bool XmlDecimal::operator<=(const mpf_class &b) const {
    return getMpfValue()<=b;
}

bool XmlDecimal::operator>=(const mpf_class &b) const {
    return getMpfValue()>=b;
}

bool XmlDecimal::operator<(const mpf_class &b) const {
    return getMpfValue()<b;
}

bool XmlDecimal::operator>(const mpf_class &b) const {
    return getMpfValue()>b;
}
    
%%class xmlbeansxx::XmlDecimal::Factory
XmlDecimalPtr XmlDecimal::Factory::newInstance(const char *value) {
    XmlDecimalPtr v(newInstance());
    v->setSimpleContent(value);
    return v;
}

XmlDecimalPtr XmlDecimal::Factory::newInstance(double value) {
    XmlDecimalPtr v(newInstance());
    v->setMpfValue(value);
    return v;
}

XmlDecimalPtr XmlDecimal::Factory::newInstance(const mpf_class &value) {
    XmlDecimalPtr v(newInstance());
    v->setMpfValue(value);
    return v;
}

%%class xmlbeansxx::XmlLong::Factory
XmlLongPtr XmlLong::Factory::newInstance(const char *value) {
    XmlLongPtr v(newInstance());
    v->setSimpleContent(value);
    return v;
}

XmlLongPtr XmlLong::Factory::newInstance(const mpz_class &value) {
    XmlLongPtr v(newInstance());
    v->setMpzValue(value);
    return v;
}

%%class xmlbeansxx::XmlInt::Factory
XmlIntPtr XmlInt::Factory::newInstance(const char *value) {
    XmlIntPtr v(newInstance());
    v->setSimpleContent(value);
    return v;
}

XmlIntPtr XmlInt::Factory::newInstance(int value) {
    XmlIntPtr v(newInstance());
    v->setIntValue(value);
    return v;
}


%%class xmlbeansxx::XmlDateTime
log4cxx::LoggerPtr XmlDateTime::log = log4cxx::Logger::getLogger(std::string("xmlbeansxx.XmlDateTime"));

bool XmlDateTime::operator==(const XmlDateTime &b) const {
    return !((*this)<b) && !(b<(*this));
}
bool XmlDateTime::operator!=(const XmlDateTime &b) const {
    return !(!((*this)<b) && !(b<(*this)));
}
bool XmlDateTime::operator<=(const XmlDateTime &b) const {
    return !(b<(*this));
}
bool XmlDateTime::operator>=(const XmlDateTime &b) const {
    return !((*this)<b);
}
bool XmlDateTime::operator>(const XmlDateTime &b) const {
    return b<(*this);
}
bool XmlDateTime::operator<(const XmlDateTime &b) const {
    XmlDatePtr d(datePart());
    XmlTimePtr t(timePart());

    XmlDatePtr bd(b.datePart());
    XmlTimePtr bt(b.timePart());

    if ((*d)==(*bd)) return (*t)<(*bt);
    else return (*d)<(*bd);
}

XmlTimePtr XmlDateTime::timePart() const {
    std::string dt=getSimpleContent();
    int p=dt.find('T');
    if (p==-1) throw XmlSimpleTypeException("T separator not found in dateTime",dt);
    return XmlTime::Factory::newInstance(dt.substr(p+1));
}

XmlDatePtr XmlDateTime::datePart() const {
    std::string dt=getSimpleContent();
    int p=dt.find('T');
    if (p==-1) throw XmlSimpleTypeException("T separator not found in dateTime",dt);
    return XmlDate::Factory::newInstance(dt.substr(0,p));
}

CalendarPtr XmlDateTime::getCalendarValue() const {
    throw NotImplementedException("XmlDateTime::getCalendarValue");
    return CalendarPtr();
}

void XmlDateTime::setCalendarValue(const boost::shared_ptr<xmlbeansxx::Calendar> &v) {
    throw NotImplementedException("XmlDateTime::getCalendarValue");
}

%%class xmlbeansxx::XmlTime
log4cxx::LoggerPtr XmlTime::log = log4cxx::Logger::getLogger(std::string("xmlbeansxx.XmlTime"));

bool XmlTime::operator==(const XmlTime &b) const {
    return !((*this)<b) && !(b<(*this));
}
bool XmlTime::operator!=(const XmlTime &b) const {
    return !(!((*this)<b) && !(b<(*this)));
}
bool XmlTime::operator<=(const XmlTime &b) const {
    return !(b<(*this));
}
bool XmlTime::operator>=(const XmlTime &b) const {
    return !((*this)<b);
}
bool XmlTime::operator>(const XmlTime &b) const {
    return b<(*this);
}
bool XmlTime::operator<(const XmlTime &b) const {
    return getSimpleContent()<b.getSimpleContent();
}

CalendarPtr XmlTime::getCalendarValue() const {
    throw NotImplementedException("XmlTime::getCalendarValue");
    return CalendarPtr();
}

void XmlTime::setCalendarValue(const boost::shared_ptr<xmlbeansxx::Calendar> &v) {
    throw NotImplementedException("XmlTime::setCalendarValue");
}

%%class xmlbeansxx::XmlDate
log4cxx::LoggerPtr XmlDate::log = log4cxx::Logger::getLogger(std::string("xmlbeansxx.XmlDate"));

XmlDate::operator boost::gregorian::date() const {
    return getDateValue();
}

bool XmlDate::operator==(const XmlDate &b) const {
    return !((*this)<b) && !(b<(*this));
}
bool XmlDate::operator!=(const XmlDate &b) const {
    return !(!((*this)<b) && !(b<(*this)));
}
bool XmlDate::operator<=(const XmlDate &b) const {
    return !(b<(*this));
}
bool XmlDate::operator>=(const XmlDate &b) const {
    return !((*this)<b);
}
bool XmlDate::operator>(const XmlDate &b) const {
    return b<(*this);
}
bool XmlDate::operator<(const XmlDate &b) const {
    return getSimpleContent()<b.getSimpleContent();
}

boost::gregorian::date XmlDate::getDateValue() const {
    std::string v=TextUtils::collapse(getContents()->getSimpleContent());
    if (!TextUtils::checkDate(v)) {
        throw XmlIllegalValueException("xs:date",v);
    }
    return boost::gregorian::from_string(v);
}
    
CalendarPtr XmlDate::getCalendarValue() const {
    throw NotImplementedException("XmlDate::getCalendarValue");
    return CalendarPtr();
}

void XmlDate::setCalendarValue(const boost::shared_ptr<xmlbeansxx::Calendar> &v) {
    throw NotImplementedException("XmlDate::setCalendarValue");
}

void XmlDate::setDateValue(const boost::gregorian::date &d) {
    getContents()->setSimpleContent(boost::gregorian::to_iso_extended_string(d));
}

int XmlDate::daysFrom(const XmlDatePtr &from) const {
    return (getDateValue() - from->getDateValue()).days();
}

%%class xmlbeansxx::XmlGDay
boost::shared_ptr<xmlbeansxx::Calendar> XmlGDay::getCalendarValue() const {
    throw NotImplementedException("XmlGDay::getCalendarValue");
    return boost::shared_ptr<xmlbeansxx::Calendar>();
}

void XmlGDay::setCalendarValue(const boost::shared_ptr<xmlbeansxx::Calendar> &v) {
    throw NotImplementedException("XmlGDay::setCalendarValue");
}
    
%%class xmlbeansxx::XmlGMonth
boost::shared_ptr<xmlbeansxx::Calendar> XmlGMonth::getCalendarValue() const {
    throw NotImplementedException("XmlGMonth::getCalendarValue");
    return boost::shared_ptr<xmlbeansxx::Calendar>();
}

void XmlGMonth::setCalendarValue(const boost::shared_ptr<xmlbeansxx::Calendar> &v) {
    throw NotImplementedException("XmlGMonth::setCalendarValue");
}
    
%%class xmlbeansxx::XmlGMonthDay
boost::shared_ptr<xmlbeansxx::Calendar> XmlGMonthDay::getCalendarValue() const {
    throw NotImplementedException("XmlGMonthDay::getCalendarValue");
    return boost::shared_ptr<xmlbeansxx::Calendar>();
}

void XmlGMonthDay::setCalendarValue(const boost::shared_ptr<xmlbeansxx::Calendar> &v) {
    throw NotImplementedException("XmlGMonthDay::getCalendarValue");
}
    
%%class xmlbeansxx::XmlGYear
boost::shared_ptr<xmlbeansxx::Calendar> XmlGYear::getCalendarValue() const {
    throw NotImplementedException("XmlGYear::getCalendarValue");
    return boost::shared_ptr<xmlbeansxx::Calendar>();
}

void XmlGYear::setCalendarValue(const boost::shared_ptr<xmlbeansxx::Calendar> &v) {
    throw NotImplementedException("XmlGYear::getCalendarValue");
}
    
%%class xmlbeansxx::XmlGYearMonth
boost::shared_ptr<xmlbeansxx::Calendar> XmlGYearMonth::getCalendarValue() const {
    throw NotImplementedException("XmlGYearMonth::getCalendarValue");
    return boost::shared_ptr<xmlbeansxx::Calendar>();
}

void XmlGYearMonth::setCalendarValue(const boost::shared_ptr<xmlbeansxx::Calendar> &v) {
    throw NotImplementedException("XmlGYearMonth::getCalendarValue");
}
    

%%class xmlbeansxx::XmlBase64Binary
xmlbeansxx::shared_array<unsigned char> XmlBase64Binary::getByteArrayValue() const {
    return TextUtils::base64Decode(getContents()->getSimpleContent());
}

void XmlBase64Binary::setByteArrayValue(xmlbeansxx::shared_array<unsigned char> v) {
    getContents()->setSimpleContent(TextUtils::base64Encode(v));
}
    

%%class xmlbeansxx::XmlHexBinary
xmlbeansxx::shared_array<unsigned char> XmlHexBinary::getByteArrayValue() const {
    throw NotImplementedException("XmlHexBinary::getByteValue");
    return xmlbeansxx::shared_array<unsigned char>();
}

void XmlHexBinary::setByteArrayValue(xmlbeansxx::shared_array<unsigned char> v) {
    throw NotImplementedException("XmlHexBinary::getByteValue");
}
    
%%class xmlbeansxx::XmlQName
boost::shared_ptr<xmlbeansxx::QName> XmlQName::getQNameValue() const {
    throw NotImplementedException("XmlQName::getQNameValue");
    return boost::shared_ptr<xmlbeansxx::QName>();
}

void XmlQName::setQNameValue(const boost::shared_ptr<xmlbeansxx::QName> &v) {
    throw NotImplementedException("XmlQName::getQNameValue");
}

%%class xmlbeansxx::XmlFloat
float XmlFloat::getFloatValue() const {
  TRACER2(log,"getFloatValue")
  LOG4CXX_DEBUG(log,"value:"+getContents()->getSimpleContent());
  std::istringstream iss(getContents()->getSimpleContent());
  float floatVal;
  iss >> floatVal;
  if (iss.fail()) {
    throw IllegalArgumentsException(std::string("Cannot convert value='")
                                    + getSimpleContent() + std::string("' to float."));
    return 0.0;
  } else {
    return floatVal;
  }
}

void XmlFloat::setFloatValue(float v) {
  getContents()->setSimpleContent(TextUtils::floatToString(v));
}

%%class xmlbeansxx::XmlDouble
double XmlDouble::getDoubleValue() const {
  TRACER2(log,"getDoubleValue")
  LOG4CXX_DEBUG(log,"value:"+getContents()->getSimpleContent());
  std::istringstream iss(getContents()->getSimpleContent());
  double doubleVal;
  iss >> doubleVal;
  if (iss.fail()) {
    throw IllegalArgumentsException(std::string("Cannot convert value='")
                                    + getSimpleContent() + std::string("' to double."));
    return 0.0;
  } else {
    return doubleVal;
  }
}

void XmlDouble::setDoubleValue(double v) {
  getContents()->setSimpleContent(TextUtils::doubleToString(v));
}
    
%%

