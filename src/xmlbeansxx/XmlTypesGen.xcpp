/*
    Copyright 2004-2005 TouK s.c.
    
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License. */



%%preamble

#include "TextUtils.h"
#include "TypeSystem.h"
#include "xml-fragment.h"
#include "defs.h"
#include "Query.h"
//#include "XmlArray.h"

#include "BeansException.h"
#include "Tracer.h"



namespace xmlbeansxx {
std::string istreamToString(std::istream &in) {
    std::string s,s2;
    while (true) {
        in>>s2;
        if (in.eof())
            break;
        s+=s2;
    }
    return s;
}

class NoExchangeEntitiesXmlObject: public XmlObject {
    public:
    virtual std::string exchangeEntities(const std::string& str) const { return str; }
};


DECLARE_PTR_CODE(std::string,StringPtr,constStringPtr)

Map_String_Int::Map_String_Int() {}
/*
Map_String_Int::Map_String_Int(const Map_String_Int &b): std::map<std::string,int>(b) {}

}*/

Map_String_Int::Map_String_Int(const Map_String_Int &b): __gnu_cxx::hash_map<StoreString,int,StoreStringHashFn>(b) {}

}

%%class xmlbeansxx::XmlObject
LOGGER_PTR_SET(XmlObject::log,"xmlbeansxx.XmlObject");


void XmlObject::createContents()
{
	if(!contents){
		contents = ContentsPtr(new Contents(getSchemaType()));
	}
}
bool XmlObject::hasContents() const
{
	return contents!=NULL;
}

XmlObject::~XmlObject() {
}

std::pair<std::string,std::string> XmlObject::getXpathToken(std::string xpath) const {
    int p=xpath.find('/');
    if (p==-1)
        return std::pair<std::string,std::string>(xpath,std::string());
    else
        return std::pair<std::string,std::string>(xpath.substr(0,p),xpath.substr(p+1));
}

int XmlObject::documentElementNamespaceID() const { return -1; }

std::string XmlObject::digest() {
	if(!contents) return "NULL";
    	return contents->digest(); 
}

XmlObject::operator bool() const{
	return hasContents();
}

bool XmlObject::setAnyElement(const QName& elementName,const std::string& anyContent) {
    NoExchangeEntitiesXmlObject obj;
    obj.setSimpleContent(anyContent);
    xmlbeansxx::Contents::Walker::setElem(*this,elementName,obj.contents);
 
    return true;
}


void XmlObject::serialize(std::ostream &o,XmlOptions options)  {
    TRACER(log,"serialize");
    xmlbeansxx::definitions::XmlFragmentDocument doc=xmlbeansxx::definitions::XmlFragmentDocument::Factory::newInstance();
    doc.cgetXmlFragment().setElement(*this);
    doc.serialize(o,options);

/*    if (options.getPrintXmlDeclaration())
        o<<"<?xml version='1.0' encoding='UTF-8'?>\n";

    o<<"<d:xml-fragment xmlns:d='http://xmlbeans.apache.org/definitions' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xmlns:xs='http://www.w3.org/2001/XMLSchema'><d:element";
    xmlbeansxx::Contents::Walker::serialize2(*this,-1,true,QName("","d:element"),o,getSchemaType());
    o<<"</d:xml-fragment>\n";
*/
}

std::string XmlObject::toString(XmlOptions options){
    std::ostringstream ss;
    serialize(ss,options);
    return ss.str();
}

/** STAWEL ??????????
#ifdef BOOST_HAS_THREADS
boost::recursive_mutex &XmlObject::mutex() const {
    return contents->mutex;
}
#endif
**/

void XmlObject::swapContents(const ContentsPtr& p)
{
    contents.reset();
    contents = p;
}

/*void XmlObject::swapContents(const constContentsPtr& p)
{
    contents.reset();
    contents = p;
}
*/

XmlObjectPtr XmlObject::clone() const {
    XmlObjectPtr n=getSchemaType()->createFn();
    n->swapContents(this->contents->clone());

//    xmlbenasxx::Contents::Walker::copyFrom(n,this->contents);
    n->setSimpleContent(getSimpleContent());
    return n;
}

std::string XmlObject::getSimpleContent() const {
    //logger.debug("XmlObject::getSimpleContent");
    return xmlbeansxx::Contents::Walker::getSimpleContent(*this);
}

void XmlObject::setSimpleContent(const std::string &value) {
    //logger.debug("XmlObject::setSimpleContent");
    const SchemaType *st=getSchemaType();
    
    createContents();
    SchemaType::CONTENT_TYPE ct=st->getContentType();
    if (ct==SchemaType::SIMPLE_CONTENT || ct==SchemaType::MIXED_CONTENT || ct==SchemaType::NOT_COMPLEX_TYPE) {
        if (getSchemaType()->whitespaceRule==SchemaType::WS_COLLAPSE) {
            xmlbeansxx::Contents::Walker::setSimpleContent(*this,TextUtils::collapse(value));
        } else {
            xmlbeansxx::Contents::Walker::setSimpleContent(*this,value);
        }
    }
}

std::string XmlObject::getCanonicalContent() const {
    return getSimpleContent();
}

XmlObject XmlObject::query(const QName &elementName,QueryNodePtr queryExpr) const {
    TRACER(log,"query");
    std::vector<ContentsPtr> elems=xmlbeansxx::Contents::Walker::getElemArray(*this,elementName);
    
    FOREACH(it,elems) {
        if (*it) {
            if (queryExpr->getBooleanValue(XmlObject(*it))) {
                return XmlObject(*it);
            }
        }
    }
    return XmlObject();
}

XmlObject XmlObject::cquery(const QName & elementName,QueryNodePtr queryExpr,ObjectCreatorFn createFn) {
    TRACER(log,"cquery");
    
    XmlObject r=query(elementName,queryExpr);
    if (!r.hasContents()) {
        r=createFn();
        xmlbeansxx::Contents::Walker::appendElem(*this,elementName,r.contents);
    }
    return r;
}


void XmlObject::free() {
    contents->free();
    contents.reset();
}


XmlObject::XmlObject(const ContentsPtr &p) : contents(p) { };

std::string XmlObject::exchangeEntities(const std::string& str) const {
    return TextUtils::exchangeEntities(str);
}

/*
template<class T>
boost::shared_ptr<T> XmlObject::defaultValue(boost::shared_ptr<T> value,std::string defaultText) const {
    if (value==NULL) { 
        value=boost::shared_ptr<T>(new T());
        value->setSimpleContent(defaultText);
    }
    return value;
}

template<class T>
std::vector<boost::shared_ptr<T> > &XmlObject::defaultArrayValue(std::vector<boost::shared_ptr<T> > &array_value,std::string defaultText) const {
    typename std::vector<boost::shared_ptr<T> >::iterator it;
    for(it=array_value.begin();it!=array_value.end();it++) {
        if (*it==NULL) {
            *it=boost::shared_ptr<T>(new T());
            it->setSimpleContent(defaultText);
        }
    }
    return array_value;
}*/

%%class xmlbeansxx::XmlAnySimpleType
std::string XmlAnySimpleType::getStringValue() const {
    return getSimpleContent();
}

void XmlAnySimpleType::setStringValue(const std::string &v) {
    setSimpleContent(v);
}


%%class xmlbeansxx::XmlBoolean
LOGGER_PTR_SET(XmlBoolean::log,"xmlbeansxx.XmlBoolean");

bool XmlBoolean::getBooleanValue() const {
    TRACER(log,"getBooleanValue");
    LOG4CXX_DEBUG(log,"value:"+getSimpleContent());
    bool boolVal;
    if (getSimpleContent()=="0") {
        boolVal=false;
    } else if (getSimpleContent()=="1") {
        boolVal=true;
    } else if (getSimpleContent()=="false") {
        LOG4CXX_DEBUG(log,"is false"); boolVal=false;
    } else if (getSimpleContent()=="true") {
        boolVal=true;
    } else throw XmlIllegalValueException("xs:boolean",getSimpleContent());
    return boolVal;
}

void XmlBoolean::setBooleanValue(bool v) {
    if (v==true) setSimpleContent("true");
    else setSimpleContent("false");
}

std::string XmlBoolean::getCanonicalContent() const {
    bool b=getBooleanValue();
    if (b) return "true";
    else return "false";
}

XmlBoolean XmlBoolean::operator==(const XmlBoolean &b) const {
    return XmlBoolean(getBooleanValue()==b.getBooleanValue());
}

XmlBoolean XmlBoolean::operator !() const {
    return XmlBoolean(!getBooleanValue());
}

XmlBoolean XmlBoolean::operator ||(const XmlBoolean &b) const {
    return XmlBoolean(getBooleanValue()|| b.getBooleanValue());
}

XmlBoolean XmlBoolean::operator &&(const XmlBoolean &b) const {
    return XmlBoolean(getBooleanValue() && b.getBooleanValue());
}

XmlBoolean::operator bool() const {
    return getBooleanValue();
}

%%class xmlbeansxx::XmlString
LOGGER_PTR_SET(XmlString::log,"xmlbeansxx.XmlString");


XmlString::operator std::string() const {
    return getSimpleContent();
}

bool XmlString::operator==(const XmlString &b) const {
    return getSimpleContent()==b.getSimpleContent();
}
bool XmlString::operator!=(const XmlString &b) const {
    return getSimpleContent()!=b.getSimpleContent();
}

XmlString XmlString::operator+(const XmlString &b) const {
    return XmlString(getSimpleContent()+b.getSimpleContent());
}

XmlString XmlString::substring(int beginIndex) const {
    return substring(beginIndex,length());
}

XmlString XmlString::substring(int beginIndex,int endIndex) const {
    TRACER(log,"substring");
    std::string s(getSimpleContent());
    if (beginIndex<0) {
        beginIndex+=s.size();
    }
    if (endIndex<0) {
        endIndex+=s.size();
    }
    if (!( beginIndex>=0 && beginIndex<=int(s.size()) && 
           endIndex>=0 && endIndex<=int(s.size()) &&
           beginIndex<=endIndex ))
        throw IllegalArgumentsException(std::string("in substring '")+s
                +"' beginIndex:"+TextUtils::intToString(beginIndex)
                +" endIndex:"+TextUtils::intToString(endIndex));
    
    return XmlString(s.substr(beginIndex,endIndex-beginIndex));
}

bool XmlString::endsWith(const XmlString &b) const {
    std::string s=b.getSimpleContent();
    std::string s2=getSimpleContent();
    return s2.substr(s2.size()-s.size())==s;
}

int XmlString::length() const {
    return getSimpleContent().size();
}

%%class xmlbeansxx::XmlInteger
LOGGER_PTR_SET(XmlInteger::log,"xmlbeansxx.XmlIteger");

void XmlInteger::setSimpleContent(const std::string &value) {
    XmlObject::setSimpleContent(value);
    setMpzValue(getMpzValue());
}

XmlInteger::operator int() const {
    return getIntValue();
}
XmlInteger::operator mpz_class() const {
    return getMpzValue();
}

%%class xmlbeansxx::XmlDecimal
LOGGER_PTR_SET(XmlDecimal::log,"xmlbeansxx.XmlDecimal");

mpf_class XmlDecimal::getMpfValue() const {
    TRACER(log,"getMpfValue");
    std::string v=TextUtils::collapse(getSimpleContent());
    if (!TextUtils::checkDecimal(v)) 
        throw XmlIllegalValueException("xs:decimal",v);
    return mpf_class(v);
}

void XmlDecimal::setMpfValue(const mpf_class &v) {
    std::ostringstream ss;
    ss << std::fixed;
    int fd=getSchemaType()->fractionDigits;
    if (fd!=-1) { ss.precision(fd); }
    ss << v;
    XmlObject::setSimpleContent(ss.str());
}

mpz_class XmlDecimal::getMpzValue() const {
    TRACER(log,"getMpzValue");
    std::string v=TextUtils::collapse(getSimpleContent());
    if (!TextUtils::checkInteger(v)) 
        throw XmlIllegalValueException("xs:integer",v);
    return mpz_class(v);
}

void XmlDecimal::setMpzValue(const mpz_class &v) {
    std::ostringstream ss;
    ss << v;
    XmlObject::setSimpleContent(ss.str());
}

int XmlDecimal::getIntValue() const {
    mpz_class v=getMpzValue();
    if (v.fits_sint_p()) {
        return v.get_si();
    } else {
        throw IllegalArgumentsException(std::string("Cannot convert decimal='")+getSimpleContent()+std::string("' to int."));
        return 0;
    }
}

void XmlDecimal::setIntValue(int v) {
    setMpzValue(v);
}

mpz_class XmlDecimal::getLongValue() const {
    return getMpzValue();
}

void XmlDecimal::setLongValue(mpz_class v) {
    setMpzValue(v);
}
    
short XmlDecimal::getShortValue() const {
    int v=getIntValue();
    if (!(v>=-32768 && v<=32767)) {
        throw IllegalArgumentsException(std::string("Cannot convert decimal='")+getSimpleContent()+std::string("' to short."));
        return 0;
    }
    return v;
}

void XmlDecimal::setShortValue(short v) {
    setIntValue(v);
}


unsigned char XmlDecimal::getByteValue() const {
    int v=getIntValue();
    if (!(v>=0 && v<=255)) {
        throw IllegalArgumentsException(std::string("Cannot convert decimal='")+getSimpleContent()+std::string("' to byte."));
        return 0;
    }
    return v;
}

void XmlDecimal::setByteValue(unsigned char v) {
    setIntValue(v);
}


void XmlDecimal::setSimpleContent(const std::string &value) {
    XmlObject::setSimpleContent(value);
    setMpfValue(getMpfValue());
}

XmlDecimal::operator mpf_class() const {
    return getMpfValue();
}

%%class xmlbeansxx::XmlDateTime
LOGGER_PTR_SET(XmlDateTime::log,"xmlbeansxx.XmlDateTime");

bool XmlDateTime::operator==(const XmlDateTime &b) const {
    return !((*this)<b) && !(b<(*this));
}
bool XmlDateTime::operator!=(const XmlDateTime &b) const {
    return !(!((*this)<b) && !(b<(*this)));
}
bool XmlDateTime::operator<=(const XmlDateTime &b) const {
    return !(b<(*this));
}
bool XmlDateTime::operator>=(const XmlDateTime &b) const {
    return !((*this)<b);
}
bool XmlDateTime::operator>(const XmlDateTime &b) const {
    return b<(*this);
}
bool XmlDateTime::operator<(const XmlDateTime &b) const {
    XmlDate d(datePart());
    XmlTime t(timePart());

    XmlDate bd(b.datePart());
    XmlTime bt(b.timePart());

    if (d==bd) return t<bt;
    else return d<bd;
}

XmlTime XmlDateTime::timePart() const {
    std::string dt=getSimpleContent();
    int p=dt.find('T');
    if (p==-1) throw XmlSimpleTypeException("T separator not found in dateTime",dt);
    return XmlTime(dt.substr(p+1));
}

XmlDate XmlDateTime::datePart() const {
    std::string dt=getSimpleContent();
    int p=dt.find('T');
    if (p==-1) throw XmlSimpleTypeException("T separator not found in dateTime",dt);
    return XmlDate(dt.substr(0,p));
}

CalendarPtr XmlDateTime::getCalendarValue() const {
    throw NotImplementedException("XmlDateTime::getCalendarValue");
    return CalendarPtr();
}

void XmlDateTime::setCalendarValue(boost::shared_ptr<xmlbeansxx::Calendar> v) {
    throw NotImplementedException("XmlDateTime::getCalendarValue");
}

%%class xmlbeansxx::XmlTime
LOGGER_PTR_SET(XmlTime::log,"xmlbeansxx.XmlTime");

bool XmlTime::operator==(const XmlTime &b) const {
    return !((*this)<b) && !(b<(*this));
}
bool XmlTime::operator!=(const XmlTime &b) const {
    return !(!((*this)<b) && !(b<(*this)));
}
bool XmlTime::operator<=(const XmlTime &b) const {
    return !(b<(*this));
}
bool XmlTime::operator>=(const XmlTime &b) const {
    return !((*this)<b);
}
bool XmlTime::operator>(const XmlTime &b) const {
    return b<(*this);
}
bool XmlTime::operator<(const XmlTime &b) const {
    return getSimpleContent()<b.getSimpleContent();
}

CalendarPtr XmlTime::getCalendarValue() const {
    throw NotImplementedException("XmlTime::getCalendarValue");
    return CalendarPtr();
}

void XmlTime::setCalendarValue(boost::shared_ptr<xmlbeansxx::Calendar> v) {
    throw NotImplementedException("XmlTime::setCalendarValue");
}

%%class xmlbeansxx::XmlDate
LOGGER_PTR_SET(XmlDate::log,"xmlbeansxx.XmlDate");


XmlDate::operator boost::gregorian::date() const {
    return getDateValue();
}

bool XmlDate::operator==(const XmlDate &b) const {
    return !((*this)<b) && !(b<(*this));
}
bool XmlDate::operator!=(const XmlDate &b) const {
    return !(!((*this)<b) && !(b<(*this)));
}
bool XmlDate::operator<=(const XmlDate &b) const {
    return !(b<(*this));
}
bool XmlDate::operator>=(const XmlDate &b) const {
    return !((*this)<b);
}
bool XmlDate::operator>(const XmlDate &b) const {
    return b<(*this);
}
bool XmlDate::operator<(const XmlDate &b) const {
    return getSimpleContent()<b.getSimpleContent();
}

boost::gregorian::date XmlDate::getDateValue() const {
    std::string v=TextUtils::collapse(getSimpleContent());
    if (!TextUtils::checkDate(v)) {
        throw XmlIllegalValueException("xs:date",v);
    }
    return boost::gregorian::from_string(v);
}
    
CalendarPtr XmlDate::getCalendarValue() const {
    throw NotImplementedException("XmlDate::getCalendarValue");
    return CalendarPtr();
}

void XmlDate::setCalendarValue(boost::shared_ptr<xmlbeansxx::Calendar> v) {
    throw NotImplementedException("XmlDate::setCalendarValue");
}

void XmlDate::setDateValue(const boost::gregorian::date &d) {
    setSimpleContent(boost::gregorian::to_iso_extended_string(d));
}

XmlInteger XmlDate::daysFrom(const XmlDate &from) const {
    return XmlInteger((int)((getDateValue()-from.getDateValue()).days()));
}

%%class xmlbeansxx::XmlGDay
boost::shared_ptr<xmlbeansxx::Calendar> XmlGDay::getCalendarValue() const {
    throw NotImplementedException("XmlGDay::getCalendarValue");
    return boost::shared_ptr<xmlbeansxx::Calendar>();
}

void XmlGDay::setCalendarValue(boost::shared_ptr<xmlbeansxx::Calendar> v) {
    throw NotImplementedException("XmlGDay::setCalendarValue");
}
    
%%class xmlbeansxx::XmlGMonth
boost::shared_ptr<xmlbeansxx::Calendar> XmlGMonth::getCalendarValue() const {
    throw NotImplementedException("XmlGMonth::getCalendarValue");
    return boost::shared_ptr<xmlbeansxx::Calendar>();
}

void XmlGMonth::setCalendarValue(boost::shared_ptr<xmlbeansxx::Calendar> v) {
    throw NotImplementedException("XmlGMonth::setCalendarValue");
}
    
%%class xmlbeansxx::XmlGMonthDay
boost::shared_ptr<xmlbeansxx::Calendar> XmlGMonthDay::getCalendarValue() const {
    throw NotImplementedException("XmlGMonthDay::getCalendarValue");
    return boost::shared_ptr<xmlbeansxx::Calendar>();
}

void XmlGMonthDay::setCalendarValue(boost::shared_ptr<xmlbeansxx::Calendar> v) {
    throw NotImplementedException("XmlGMonthDay::getCalendarValue");
}
    
%%class xmlbeansxx::XmlGYear
boost::shared_ptr<xmlbeansxx::Calendar> XmlGYear::getCalendarValue() const {
    throw NotImplementedException("XmlGYear::getCalendarValue");
    return boost::shared_ptr<xmlbeansxx::Calendar>();
}

void XmlGYear::setCalendarValue(boost::shared_ptr<xmlbeansxx::Calendar> v) {
    throw NotImplementedException("XmlGYear::getCalendarValue");
}
    
%%class xmlbeansxx::XmlGYearMonth
boost::shared_ptr<xmlbeansxx::Calendar> XmlGYearMonth::getCalendarValue() const {
    throw NotImplementedException("XmlGYearMonth::getCalendarValue");
    return boost::shared_ptr<xmlbeansxx::Calendar>();
}

void XmlGYearMonth::setCalendarValue(boost::shared_ptr<xmlbeansxx::Calendar> v) {
    throw NotImplementedException("XmlGYearMonth::getCalendarValue");
}
    

%%class xmlbeansxx::XmlBase64Binary
xmlbeansxx::shared_array<unsigned char> XmlBase64Binary::getByteArrayValue() const {
    return TextUtils::base64Decode(getSimpleContent());
}

void XmlBase64Binary::setByteArrayValue(xmlbeansxx::shared_array<unsigned char> v) {
    setSimpleContent(TextUtils::base64Encode(v));
}
    

%%class xmlbeansxx::XmlHexBinary
xmlbeansxx::shared_array<unsigned char> XmlHexBinary::getByteArrayValue() const {
    throw NotImplementedException("XmlHexBinary::getByteValue");
    return xmlbeansxx::shared_array<unsigned char>();
}

void XmlHexBinary::setByteArrayValue(xmlbeansxx::shared_array<unsigned char> v) {
    throw NotImplementedException("XmlHexBinary::getByteValue");
}
    
%%class xmlbeansxx::XmlQName
boost::shared_ptr<xmlbeansxx::QName> XmlQName::getQNameValue() const {
    throw NotImplementedException("XmlQName::getQNameValue");
    return boost::shared_ptr<xmlbeansxx::QName>();
}

void XmlQName::setQNameValue(boost::shared_ptr<xmlbeansxx::QName> v) {
    throw NotImplementedException("XmlQName::getQNameValue");
}

%%class xmlbeansxx::XmlFloat
float XmlFloat::getFloatValue() const {
  TRACER(log,"getFloatValue");
  LOG4CXX_DEBUG(log,"value:"+getSimpleContent());
  std::istringstream iss(getSimpleContent());
  float floatVal;
  iss >> floatVal;
  if (iss.fail()) {
    throw IllegalArgumentsException(std::string("Cannot convert value='")
                                    + getSimpleContent() + std::string("' to float."));
    return 0.0;
  } else {
    return floatVal;
  }
}

void XmlFloat::setFloatValue(float v) {
  setSimpleContent(TextUtils::floatToString(v));
}

%%class xmlbeansxx::XmlDouble
double XmlDouble::getDoubleValue() const {
  TRACER(log,"getDoubleValue");
  LOG4CXX_DEBUG(log,"value:"+getSimpleContent());
  std::istringstream iss(getSimpleContent());
  double doubleVal;
  iss >> doubleVal;
  if (iss.fail()) {
    throw IllegalArgumentsException(std::string("Cannot convert value='")
                                    + getSimpleContent() + std::string("' to double."));
    return 0.0;
  } else {
    return doubleVal;
  }
}

void XmlDouble::setDoubleValue(double v) {
  setSimpleContent(TextUtils::doubleToString(v));
}
    
%%

