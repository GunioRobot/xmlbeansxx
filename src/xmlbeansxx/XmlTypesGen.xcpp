/*
    Copyright 2004-2005 TouK s.c.
    
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License. */



%%preamble

#include "TextUtils.h"
#include "TypeSystem.h"
#include "xml-fragment.h"
#include "defs.h"
#include "Query.h"
#include "BeansException.h"
#include "Tracer.h"

#include <boost/date_time/posix_time/posix_time.hpp>

namespace xmlbeansxx {
std::string istreamToString(std::istream &in) {
    std::string s,s2;
    while (!in.eof()) {
        in>>s2;
        s+=s2;
    }
    return s;
}

class NoExchangeEntitiesXmlObject: public XmlObject {
    public:
    virtual std::string exchangeEntities(const std::string& str) const { return str; }
};


DECLARE_PTR_CODE(std::string,StringPtr,constStringPtr)

}



%%class xmlbeansxx::XmlObject
LOGGER_PTR_SET(XmlObject::log,"xmlbeansxx.XmlObject");


void XmlObject::createContents()
{
	if(!contents){
		contents = ContentsPtr(new Contents(getSchemaType()));
	}
}
bool XmlObject::hasContents() const
{
	return contents!=NULL;
}

XmlObject::~XmlObject() {
}

std::pair<std::string,std::string> XmlObject::getXpathToken(std::string xpath) const {
    int p=xpath.find('/');
    if (p==-1)
        return std::pair<std::string,std::string>(xpath,std::string());
    else
        return std::pair<std::string,std::string>(xpath.substr(0,p),xpath.substr(p+1));
}

int XmlObject::documentElementNamespaceID() const { return -1; }

std::string XmlObject::digest() const{
	if(!contents) return "NULL";
    	return contents->digest(); 
}

XmlObject::operator bool() const{
	return hasContents();
}

bool XmlObject::setAnyElement(const QName& elementName,const std::string& anyContent) {
    NoExchangeEntitiesXmlObject obj;
    obj.setSimpleContent(anyContent);
    xmlbeansxx::Contents::Walker::setElem(*this,elementName,obj.contents);
 
    return true;
}


void XmlObject::serialize(std::ostream &o,XmlOptions options)  const{
    TRACER(log,"serialize");
    if(!hasContents()) throw NullPtrException("Cannot serialize an empty XmlObject = " + getSchemaType()->className);

    if(getSchemaType() != getOrginSchemaType()) 
        return Contents::Walker::OrginalXmlObject(contents)->serialize(o,options);
    


    xmlbeansxx::definitions::XmlFragmentDocument doc=xmlbeansxx::definitions::XmlFragmentDocument::Factory::newInstance();
    doc.setXmlFragment(*this);
    doc.serialize(o,options);
}


std::string XmlObject::toString(XmlOptions options) const {
    std::ostringstream ss;
    serialize(ss,options);
    return ss.str();
}

const SchemaType * XmlObject::getSchemaType() const {
    if(contents) return contents->getSchemaType();
    else return getOrginSchemaType();
}


/** STAWEL ??????????
#ifdef BOOST_HAS_THREADS
boost::recursive_mutex &XmlObject::mutex() const {
    return contents->mutex;
}
#endif
**/

void XmlObject::swapContents(const ContentsPtr& p)
{
    contents.reset();
    contents = p;
}


XmlObject XmlObject::clone() const {
    XmlObjectPtr n=getSchemaType()->createFn();
    n->swapContents(this->contents->clone());

    return XmlObject(n->contents);
}

std::string XmlObject::getSimpleContent() const {
    //logger.debug("XmlObject::getSimpleContent");
    return xmlbeansxx::Contents::Walker::getSimpleContent(*this);
}

void XmlObject::setSimpleContent(const std::string &value) {
    //logger.debug("XmlObject::setSimpleContent");
    const SchemaType *st=getSchemaType();
    
    createContents();
    SchemaType::CONTENT_TYPE ct=st->getContentType();
    if (ct==SchemaType::SIMPLE_CONTENT || ct==SchemaType::MIXED_CONTENT || ct==SchemaType::NOT_COMPLEX_TYPE) {
        if (getSchemaType()->whitespaceRule==SchemaType::WS_COLLAPSE) {
            xmlbeansxx::Contents::Walker::setSimpleContent(*this,TextUtils::collapse(value));
        } else {
            xmlbeansxx::Contents::Walker::setSimpleContent(*this,value);
        }
    }
}

std::string XmlObject::getCanonicalContent() const {
    return getSimpleContent();
}



void XmlObject::free() {
    contents->free();
    contents.reset();
}


XmlObject::XmlObject(const ContentsPtr &p) : contents(p) { };

std::string XmlObject::exchangeEntities(const std::string& str) const {
    return TextUtils::exchangeEntities(str);
}

/*
template<class T>
boost::shared_ptr<T> XmlObject::defaultValue(boost::shared_ptr<T> value,std::string defaultText) const {
    if (value==NULL) { 
        value=boost::shared_ptr<T>(new T());
        value->setSimpleContent(defaultText);
    }
    return value;
}

template<class T>
std::vector<boost::shared_ptr<T> > &XmlObject::defaultArrayValue(std::vector<boost::shared_ptr<T> > &array_value,std::string defaultText) const {
    typename std::vector<boost::shared_ptr<T> >::iterator it;
    for(it=array_value.begin();it!=array_value.end();it++) {
        if (*it==NULL) {
            *it=boost::shared_ptr<T>(new T());
            it->setSimpleContent(defaultText);
        }
    }
    return array_value;
}*/

%%class xmlbeansxx::XmlAnySimpleType
std::string XmlAnySimpleType::getStringValue() const {
    return getSimpleContent();
}

void XmlAnySimpleType::setStringValue(const std::string &v) {
    setSimpleContent(v);
}


%%class xmlbeansxx::XmlBoolean
LOGGER_PTR_SET(XmlBoolean::log,"xmlbeansxx.XmlBoolean");

bool XmlBoolean::getBooleanValue() const {
    TRACER(log,"getBooleanValue");
    LOG4CXX_DEBUG(log,"value:"+getSimpleContent());
    std::string s = getSimpleContent();
//    std::transform(s.begin(), s.end(), s.begin(), tolower);
    boost::to_lower(s);
    bool boolVal;
    if (s=="0") {
        boolVal=false;
    } else if (s=="1") {
        boolVal=true;
    } else if (s=="false") {
        LOG4CXX_DEBUG(log,"is false"); boolVal=false;
    } else if (s=="true") {
        boolVal=true;
    } else throw XmlIllegalValueException("xs:boolean",getSimpleContent());
    return boolVal;
}

void XmlBoolean::setBooleanValue(bool v) {
    if (v==true) setSimpleContent("true");
    else setSimpleContent("false");
}

std::string XmlBoolean::getCanonicalContent() const {
    bool b=getBooleanValue();
    if (b) return "true";
    else return "false";
}

XmlBoolean XmlBoolean::operator==(const XmlBoolean &b) const {
    return XmlBoolean(getBooleanValue()==b.getBooleanValue());
}

XmlBoolean XmlBoolean::operator !() const {
    return XmlBoolean(!getBooleanValue());
}

XmlBoolean XmlBoolean::operator ||(const XmlBoolean &b) const {
    return XmlBoolean(getBooleanValue()|| b.getBooleanValue());
}

XmlBoolean XmlBoolean::operator &&(const XmlBoolean &b) const {
    return XmlBoolean(getBooleanValue() && b.getBooleanValue());
}

XmlBoolean::operator bool() const {
    return getBooleanValue();
}

%%class xmlbeansxx::XmlString
LOGGER_PTR_SET(XmlString::log,"xmlbeansxx.XmlString");


XmlString::operator std::string() const {
    return getSimpleContent();
}

bool XmlString::operator==(const XmlString &b) const {
    return getSimpleContent()==b.getSimpleContent();
}
bool XmlString::operator!=(const XmlString &b) const {
    return getSimpleContent()!=b.getSimpleContent();
}

XmlString XmlString::operator+(const XmlString &b) const {
    return XmlString(getSimpleContent()+b.getSimpleContent());
}

XmlString XmlString::substring(int beginIndex) const {
    return substring(beginIndex,length());
}

XmlString XmlString::substring(int beginIndex,int endIndex) const {
    TRACER(log,"substring");
    std::string s(getSimpleContent());
    if (beginIndex<0) {
        beginIndex+=s.size();
    }
    if (endIndex<0) {
        endIndex+=s.size();
    }
    if (!( beginIndex>=0 && beginIndex<=int(s.size()) && 
           endIndex>=0 && endIndex<=int(s.size()) &&
           beginIndex<=endIndex ))
        throw IllegalArgumentsException(std::string("in substring '")+s
                +"' beginIndex:"+TextUtils::intToString(beginIndex)
                +" endIndex:"+TextUtils::intToString(endIndex));
    
    return XmlString(s.substr(beginIndex,endIndex-beginIndex));
}

bool XmlString::endsWith(const XmlString &b) const {
    std::string s=b.getSimpleContent();
    std::string s2=getSimpleContent();
    return s2.substr(s2.size()-s.size())==s;
}

int XmlString::length() const {
    return getSimpleContent().size();
}

%%class xmlbeansxx::XmlInteger
LOGGER_PTR_SET(XmlInteger::log,"xmlbeansxx.XmlIteger");

void XmlInteger::setSimpleContent(const std::string &value) {
    XmlObject::setSimpleContent(value);
    setMpzValue(getMpzValue());
}

XmlInteger::operator int() const {
    return getIntValue();
}
XmlInteger::operator mpz_class() const {
    return getMpzValue();
}

%%class xmlbeansxx::XmlDecimal
LOGGER_PTR_SET(XmlDecimal::log,"xmlbeansxx.XmlDecimal");

mpf_class XmlDecimal::getMpfValue() const {
    TRACER(log,"getMpfValue");
    std::string v=TextUtils::collapse(getSimpleContent());
    if (!TextUtils::checkDecimal(v)) 
        throw XmlIllegalValueException("xs:decimal",v);
    return mpf_class(v);
}

void XmlDecimal::setMpfValue(const mpf_class &v) {
    std::ostringstream ss;
    ss << std::fixed;
    int fd=getSchemaType()->fractionDigits;
    if (fd!=-1) { ss.precision(fd); }
    ss << v;
    XmlObject::setSimpleContent(ss.str());
}

mpz_class XmlDecimal::getMpzValue() const {
    TRACER(log,"getMpzValue");
    std::string v=TextUtils::collapse(getSimpleContent());
    if (!TextUtils::checkInteger(v)) 
        throw XmlIllegalValueException("xs:integer",v);
    return mpz_class(v);
}

void XmlDecimal::setMpzValue(const mpz_class &v) {
    std::ostringstream ss;
    ss << v;
    XmlObject::setSimpleContent(ss.str());
}

int XmlDecimal::getIntValue() const {
    mpz_class v=getMpzValue();
    if (v.fits_sint_p()) {
        return v.get_si();
    } else {
        throw IllegalArgumentsException(std::string("Cannot convert decimal='")+getSimpleContent()+std::string("' to int."));
        return 0;
    }
}

void XmlDecimal::setIntValue(int v) {
    setMpzValue(v);
}

mpz_class XmlDecimal::getLongValue() const {
    return getMpzValue();
}

void XmlDecimal::setLongValue(mpz_class v) {
    setMpzValue(v);
}
    
short XmlDecimal::getShortValue() const {
    int v=getIntValue();
    if (!(v>=-32768 && v<=32767)) {
        throw IllegalArgumentsException(std::string("Cannot convert decimal='")+getSimpleContent()+std::string("' to short."));
        return 0;
    }
    return v;
}

void XmlDecimal::setShortValue(short v) {
    setIntValue(v);
}


unsigned char XmlDecimal::getByteValue() const {
    int v=getIntValue();
    if (!(v>=0 && v<=255)) {
        throw IllegalArgumentsException(std::string("Cannot convert decimal='")+getSimpleContent()+std::string("' to byte."));
        return 0;
    }
    return v;
}

void XmlDecimal::setByteValue(unsigned char v) {
    setIntValue(v);
}


void XmlDecimal::setSimpleContent(const std::string &value) {
    XmlObject::setSimpleContent(value);
    setMpfValue(getMpfValue());
}

XmlDecimal::operator mpf_class() const {
    return getMpfValue();
}

%%class xmlbeansxx::XmlDateTime
LOGGER_PTR_SET(XmlDateTime::log,"xmlbeansxx.XmlDateTime");

XmlDateTime::XmlDateTime(const boost::posix_time::ptime &pt) {
    setCalendarValue(pt);
}


bool XmlDateTime::operator==(const XmlDateTime &b) const {
    return !((*this)<b) && !(b<(*this));
}
bool XmlDateTime::operator!=(const XmlDateTime &b) const {
    return !(!((*this)<b) && !(b<(*this)));
}
bool XmlDateTime::operator<=(const XmlDateTime &b) const {
    return !(b<(*this));
}
bool XmlDateTime::operator>=(const XmlDateTime &b) const {
    return !((*this)<b);
}
bool XmlDateTime::operator>(const XmlDateTime &b) const {
    return b<(*this);
}
bool XmlDateTime::operator<(const XmlDateTime &b) const {
    XmlDate d(datePart());
    XmlTime t(timePart());

    XmlDate bd(b.datePart());
    XmlTime bt(b.timePart());

    if (d==bd) return t<bt;
    else return d<bd;
}

XmlTime XmlDateTime::timePart() const {
    std::string dt=getSimpleContent();
    std::string::size_type p=dt.find('T');

    if (p==std::string::npos) throw XmlSimpleTypeException("T separator not found in dateTime",dt);
    std::string retu=dt.substr(p+1);
    std::string::size_type z=retu.find('Z');
    return XmlTime(retu.substr(0,z));
}

XmlDate XmlDateTime::datePart() const {
    std::string dt=getSimpleContent();
    std::string::size_type p=dt.find('T');
    if (p==std::string::npos) throw XmlSimpleTypeException("T separator not found in dateTime",dt);
    return XmlDate(dt.substr(0,p));
}

boost::posix_time::ptime XmlDateTime::getCalendarValue() const {
    return boost::posix_time::ptime(datePart().getDateValue(),timePart().getTimeValue());
}

void XmlDateTime::setCalendarValue(const boost::posix_time::ptime &v) {
    XmlDate d(v);	
    XmlTime t(v);
    setSimpleContent(d.getSimpleContent() + "T" + t.getSimpleContent());
}

%%class xmlbeansxx::XmlTime
LOGGER_PTR_SET(XmlTime::log,"xmlbeansxx.XmlTime");


XmlTime::XmlTime(const boost::posix_time::ptime &pt) {
    setCalendarValue(pt);
}
XmlTime::XmlTime(const boost::posix_time::time_duration &td) {
    setTimeValue(td);
}


bool XmlTime::operator==(const XmlTime &b) const {
    return !((*this)<b) && !(b<(*this));
}
bool XmlTime::operator!=(const XmlTime &b) const {
    return !(!((*this)<b) && !(b<(*this)));
}
bool XmlTime::operator<=(const XmlTime &b) const {
    return !(b<(*this));
}
bool XmlTime::operator>=(const XmlTime &b) const {
    return !((*this)<b);
}
bool XmlTime::operator>(const XmlTime &b) const {
    return b<(*this);
}
bool XmlTime::operator<(const XmlTime &b) const {
    return getTimeValue()<b.getTimeValue();
}

boost::posix_time::time_duration XmlTime::getTimeValue() const {
    return boost::posix_time::duration_from_string(getSimpleContent());
}
void XmlTime::setTimeValue(const boost::posix_time::time_duration &d) {
    setSimpleContent(boost::posix_time::to_simple_string(d));
}


boost::posix_time::ptime XmlTime::getCalendarValue() const {
    return boost::posix_time::ptime(boost::gregorian::date(),getTimeValue());
}

void XmlTime::setCalendarValue(const boost::posix_time::ptime & v) {
    setTimeValue(v.time_of_day());
}

%%class xmlbeansxx::XmlDate
LOGGER_PTR_SET(XmlDate::log,"xmlbeansxx.XmlDate");

XmlDate::XmlDate(const boost::posix_time::ptime &pt) {
    setCalendarValue(pt);
}
XmlDate::XmlDate(const boost::gregorian::date &gd) {
    setDateValue(gd);
}



XmlDate::operator boost::gregorian::date() const {
    return getDateValue();
}

bool XmlDate::operator==(const XmlDate &b) const {
    return !((*this)<b) && !(b<(*this));
}
bool XmlDate::operator!=(const XmlDate &b) const {
    return !(!((*this)<b) && !(b<(*this)));
}
bool XmlDate::operator<=(const XmlDate &b) const {
    return !(b<(*this));
}
bool XmlDate::operator>=(const XmlDate &b) const {
    return !((*this)<b);
}
bool XmlDate::operator>(const XmlDate &b) const {
    return b<(*this);
}
bool XmlDate::operator<(const XmlDate &b) const {
    return getSimpleContent()<b.getSimpleContent();
}

boost::gregorian::date XmlDate::getDateValue() const {
    std::string v=TextUtils::collapse(getSimpleContent());
    if (!TextUtils::checkDate(v)) {
        throw XmlIllegalValueException("xs:date",v);
    }
    return boost::gregorian::from_string(v);
}
    
boost::posix_time::ptime XmlDate::getCalendarValue() const {
    return boost::posix_time::ptime(getDateValue());
}

void XmlDate::setCalendarValue(const boost::posix_time::ptime &v) {
	setDateValue(v.date());
}

void XmlDate::setDateValue(const boost::gregorian::date &d) {
    setSimpleContent(boost::gregorian::to_iso_extended_string(d));
}

XmlInteger XmlDate::daysFrom(const XmlDate &from) const {
    return XmlInteger((int)((getDateValue()-from.getDateValue()).days()));
}

%%class xmlbeansxx::XmlGDay
boost::posix_time::ptime XmlGDay::getCalendarValue() const {
    throw NotImplementedException("XmlGDay::getCalendarValue");
}

void XmlGDay::setCalendarValue(const boost::posix_time::ptime & v) {
    throw NotImplementedException("XmlGDay::setCalendarValue");
}
    
%%class xmlbeansxx::XmlGMonth
boost::posix_time::ptime XmlGMonth::getCalendarValue() const {
    throw NotImplementedException("XmlGMonth::getCalendarValue");
}

void XmlGMonth::setCalendarValue(const boost::posix_time::ptime & v) {
    throw NotImplementedException("XmlGMonth::setCalendarValue");
}
    
%%class xmlbeansxx::XmlGMonthDay
boost::posix_time::ptime XmlGMonthDay::getCalendarValue() const {
    throw NotImplementedException("XmlGMonthDay::getCalendarValue");
}

void XmlGMonthDay::setCalendarValue(const boost::posix_time::ptime & v) {
    throw NotImplementedException("XmlGMonthDay::getCalendarValue");
}
    
%%class xmlbeansxx::XmlGYear
boost::posix_time::ptime  XmlGYear::getCalendarValue() const {
    throw NotImplementedException("XmlGYear::getCalendarValue");
}

void XmlGYear::setCalendarValue(const boost::posix_time::ptime & v) {
    throw NotImplementedException("XmlGYear::getCalendarValue");
}
    
%%class xmlbeansxx::XmlGYearMonth
boost::posix_time::ptime XmlGYearMonth::getCalendarValue() const {
    throw NotImplementedException("XmlGYearMonth::getCalendarValue");
}

void XmlGYearMonth::setCalendarValue(const boost::posix_time::ptime & v) {
    throw NotImplementedException("XmlGYearMonth::getCalendarValue");
}
    

%%class xmlbeansxx::XmlBase64Binary
xmlbeansxx::shared_array<unsigned char> XmlBase64Binary::getByteArrayValue() const {
    return TextUtils::base64Decode(getSimpleContent());
}

void XmlBase64Binary::setByteArrayValue(xmlbeansxx::shared_array<unsigned char> v) {
    setSimpleContent(TextUtils::base64Encode(v));
}
    

%%class xmlbeansxx::XmlHexBinary
xmlbeansxx::shared_array<unsigned char> XmlHexBinary::getByteArrayValue() const {
    throw NotImplementedException("XmlHexBinary::getByteValue");
    return xmlbeansxx::shared_array<unsigned char>();
}

void XmlHexBinary::setByteArrayValue(xmlbeansxx::shared_array<unsigned char> v) {
    throw NotImplementedException("XmlHexBinary::getByteValue");
}
    
%%class xmlbeansxx::XmlQName
boost::shared_ptr<xmlbeansxx::QName> XmlQName::getQNameValue() const {
    throw NotImplementedException("XmlQName::getQNameValue");
    return boost::shared_ptr<xmlbeansxx::QName>();
}

void XmlQName::setQNameValue(boost::shared_ptr<xmlbeansxx::QName> v) {
    throw NotImplementedException("XmlQName::getQNameValue");
}

%%class xmlbeansxx::XmlFloat
float XmlFloat::getFloatValue() const {
  TRACER(log,"getFloatValue");
  LOG4CXX_DEBUG(log,"value:"+getSimpleContent());
  std::istringstream iss(getSimpleContent());
  float floatVal;
  iss >> floatVal;
  if (iss.fail()) {
    throw IllegalArgumentsException(std::string("Cannot convert value='")
                                    + getSimpleContent() + std::string("' to float."));
    return 0.0;
  } else {
    return floatVal;
  }
}

void XmlFloat::setFloatValue(float v) {
  setSimpleContent(TextUtils::floatToString(v));
}

%%class xmlbeansxx::XmlDouble
double XmlDouble::getDoubleValue() const {
  TRACER(log,"getDoubleValue");
  LOG4CXX_DEBUG(log,"value:"+getSimpleContent());
  std::istringstream iss(getSimpleContent());
  double doubleVal;
  iss >> doubleVal;
  if (iss.fail()) {
    throw IllegalArgumentsException(std::string("Cannot convert value='")
                                    + getSimpleContent() + std::string("' to double."));
    return 0.0;
  } else {
    return doubleVal;
  }
}

void XmlDouble::setDoubleValue(double v) {
  setSimpleContent(TextUtils::doubleToString(v));
}
    
%%

