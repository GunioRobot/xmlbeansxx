/*
    Copyright 2004-2005 TouK s.c.
    
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License. */


%%preamble
#include "BoostAssert.h"
#include <log4cxx/logger.h>
#include "SchemaProperty.h"
#include "SchemaType.h"
#include "StoreString.h"
#include "XmlTokenSource.h"
#include "XmlOptions.h"
#include "Array.h"
#include "SimpleValue.h"
#include "CoreTypes.h"
#include "QName.h"

namespace xmlbeansxx {
}

%%class xmlbeansxx::XmlObject
public:
    virtual ~XmlObject_I() {}
    virtual XmlObject changeType(SchemaType type) = 0;

    /** 
     * Serializes XmlObject to output stream. 
     * @param options specify some serialization options
     */
    virtual void save(std::ostream &out, const XmlOptions &options = XmlOptions::New()) = 0;

    /** 
     * Serializes XmlObject to string. 
     * @param options specify some serialization options
     */
    virtual String toString(const XmlOptions &options = XmlOptions::New()) = 0;
    
    /**
     * @return deep copy of this XmlObject
     */
    virtual XmlObject copy() = 0;

    /**
     * True if the xml values are equal. Two different objects
     * (which are distinguished by equals(obj) == false) may of
     * course have equal values (valueEquals(obj) == true).
     * <p>
     * Usually this method can be treated as an ordinary equvalence
     * relation, but actually it is not is not transitive.
     * Here is a precise specification:
     * <p>
     * There are two categories of XML object: objects with a known
     * instance type, and objects whose only known type is one of the
     * ur-types (either AnyType or AnySimpleType). The first category
     * is compared in terms of logical value spaces, and the second
     * category is compared lexically.
     * <p>
     * Within each of these two categories, valueEquals is a well-behaved
     * equivalence relation. However, when comparing an object of known
     * type with an object with ur-type, the comparison is done by attempting
     * to convert the lexical form of the ur-typed object into the other
     * type, and then comparing the results. Ur-typed objects are therefore
     * treated as lexical wildcards and may be equal to objects in different
     * value spaces, even though the objects in different value spaces are
     * not equal to each other.
     * <p>
     * For example, the anySimpleType value "1" will compare as an
     * equalValue to the string "1", the float value "1.0", the double
     * value "1.0", the decimal "1", and the GYear "1", even though
     * all these objects will compare unequal to each other since they
     * lie in different value spaces.
     */
    virtual boolean valueEquals(const XmlObject &obj) = 0;
    virtual int valueHashCode() = 0;
%%

